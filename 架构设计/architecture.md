## 面向服务的技术体系架构

### TCP协议的RPC
    RPC Remote Process Call 远程过程调用，实现有：grpc、thrift等。
    分为客户端和服务端，让人感觉调用服务端的方法就象调用本地方法一样简单，但是其实经过网络的，参数和返回值都是需要进行序列化
    和反序列化操作的，调用的过程还有会路由，服务端还会设计注册和发现，failover 等
#### 对象的序列化
    将对象转换为二进制流的过程称之为对象的序列化
    将二进制流恢复为对象的过程称为对象的反序列化
    序列化的方案有很多，例如google protocal buffer、java自带的序列化、json、xml、hessian等。
    protocal buffer： 需要自己定义proto文件
    java自带：类要实现Serializable 或者 ExternalSeralizable 【二者的区别需要注意】
    简单说下基于java socket实现一个乞版的rpc：定义一个接口，服务端来实现，
    服务启动服务之后，会实例化相应的服务和socket 端口等待连接接，客户端引用这个接口，通过socket接口，要调用的接口、
    方法、方法参数和类型序列化后发送给服务端的socket，服务端接受到连接之后，读取完流，进行反序列化，得到要调用的接口、
    方法、方法参数、和方法参数类型，然后找到相对应实现类，并调用用相应的方法执行，然后拿到返回值，在进行序列化，发送给
    客户端，接着客户端读取服务端响应，进行返回值的反序列化操作，至此一次rpc调用结束。为了达到更高的吞吐量，可socket可以用
    nio，来实现或者池化技术来实现。
    
    
 ### 设计架构的目的：解决软件复杂度带来的问题
 ### 复杂度： 高性能   
       单台计算机内部复杂度，进程和线程
       多台计算机集群复杂度，F5，lVS，HAPROXY ，NGINX，keepalived，任务分解【业务分解，业务垂直拆分，来简化系统的复杂度，并不是拆分越多越好】
 
### 复杂度： 高可用
     本质上都是通过冗余来实现
     单机备份，跨机房备份，任务备份，keepalived，主备【冷备、温备、热备】、主主。      
     存储高可用
     传输线路的传输延迟、传输中断 、阻塞等导致数据的不一致。
     高可用的复杂度就是数据的一致性确保
     CAP定理
     高可用状态决策：
     独裁式：决策者有单点问题
     协商式：主备决策，一个主，另一个作为备份。
     民主：如zookeeper，防止脑裂，奇数，过半才有效。
### 复杂度： 可扩展性
    
            